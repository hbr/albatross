<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Alba_core__Build (alba.Alba_core__Build)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">alba</a> &#x00BB; Alba_core__Build</nav><h1>Module <code>Alba_core__Build</code></h1><p>A core internal module to support term building. Do not use outside of core directly.</p><p>Basic Idea ==========</p><p>There is a stack of to be built terms. When the construction of term starts, the term can get some type requirement.</p><p>Invariant =========</p><ul><li>Only terms which are welltyped in the context are constructed.</li></ul><ul><li>All terms on the stack are welltyped and satisfy their requirements or have still a chance to satisfy their requirement. The satisfaction of the requirements is checked by putting a term to the stack.</li></ul><p>Used Typing Rules =================</p><p>Product -------</p><p>Gamma |- A: sA Gamma, x:A |- B: sB Gamma |- pi_sort(sA,sB) &lt;= s ----------------------------------- Gamma |- (all (x: A). B) : s</p><p>sA sR pi_sort(sA,sR) ---------------------------------------------- * Proposition Proposition Proposition Any(i) Any(i) Any(i) Any(j) Any(max(i,j))</p><p>At the start there is on top of the stack an empty term with an optional requirement of its return type. The required type, if present, must be a sort.</p><p>Depending of the required type we push a new item onto the stack. If the required type is a proposition, then the required type of the argument type is Any. If the required type of the whole product is <code>Any(i)</code>, then the required type of the argument type is <code>Any(i)</code>.</p><p>We build the argument type and pop it and push is as a bound variable.</p><p>Then we push a new item for the result type with the same required type as the requirement of the product term onto the stack and build the result type.</p><p>Finally we pop the result type and the binder and put the product term onto the top of the stack.</p><p>Application -----------</p><p>Gamma |- f: all (x: A). B Gamma |- a: A' Gamma |- A' &lt;= A -- subtype ---------------------------------------- Gamma |- f a: B<code>x:=a</code></p><p>We start to build <code>f a</code> with a possible requirement which has to be satisfied after being applied to <code>nargs</code> arguments.</p><p><code>start_application</code> increments nargs by one. Then it builds <code>f</code>. The function term can only be built if its type is a product type.</p><p>Then we start a new term with the required type <code>A</code> from the type of <code>f</code>.</p><p>Lambda ------</p><p>Gamma |- (all (x: A): B) : s Gamma, x:A |- e: B -------------------------------------------- Gamma |- (\ (x: A) := e): all (x: A): B</p></header><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Info/index.html">Info</a> : <a href="../Fmlib/Module_types/index.html#module-type-ANY">Fmlib.Module_types.ANY</a>) <span>&#45;&gt;</span> <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></div></body></html>