<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fmlib__Pretty_print (alba.Fmlib__Pretty_print)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">alba</a> &#x00BB; Fmlib__Pretty_print</nav><h1>Module <code>Fmlib__Pretty_print</code></h1><p>Pretty Printer: Generate nicely formatted ascii text.</p><nav class="toc"><ul><li><a href="#overview">Overview</a><ul><li><a href="#example">Example</a></li><li><a href="#character-stream">Character Stream</a></li></ul></li><li><a href="#generate-documents">Generate Documents</a></li><li><a href="#api">API</a></li></ul></nav></header><section><header><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2></header><section><header><h3 id="example"><a href="#example" class="anchor"></a>Example</h3><p>The usage of the pretty printer is best explained by an example. Suppose we want to print the function application <code>f a b (g c d) e</code> where the function names and arguments might have different length. We create a <i>document</i> which represents the structure by</p><pre><code class="ml">let doc =
    group (
        text &quot;f&quot; &lt;+&gt; space &lt;+&gt;
        indent
            2
            (stack_or_pack
                &quot; &quot;
                [text &quot;a&quot;;
                 text &quot;b&quot;;
                 group (
                     text &quot;(g&quot; &lt;+&gt; space &lt;+&gt;
                     indent
                        2
                        (stack_or_pack &quot; &quot; [text &quot;c&quot;; text &quot;d&quot;])
                     &lt;+&gt; text &quot;)&quot;);
                 text &quot;e&quot;])
    )</code></pre><p>where <code>text &quot;blabla&quot;</code> is a document with some unbreakable text, <code>&lt;+&gt;</code> concatenates two documents, <code>space</code> is a break hint whose alternative text is a blank, <code>stack_or_pack atxt [...]</code> stacks a list of documents separated by a break hint with the alternative text <code>atxt</code>.</p><p>The command</p><pre><code class="ml">let stream = layout 5 doc </code></pre><p>creates a stream of characters which is nicely formatted using a desired line width of 5 characters. Since 5 characters are not enough to put any of the subterms completely on a line, the output is</p><pre><code class="ml">123456789012345
f
  a
  b
  (g
    c
    d)
  d</code></pre><p>i.e. each break hint is printed as a newline.</p><p>If we give the pretty printer a line width of 10, it could pack the application <code>g c d</code> on a line and print</p><pre><code class="ml">123456789012345
f
  a
  b
  (g c d)
  d</code></pre><p>If the pretty printer has enough line width e.g. a line width of 15, it can put the whole expression on a line.</p><pre><code class="ml">123456789012345
f a b (g c d) d</code></pre><p>By using <code>stack_or_pack</code> we instructed the pretty printer to either print all break hints as newlines or all break hints with their alternative texts. If we use <code>pack</code> instead of <code>stack_or_pack</code>, the pretty printer tries to pack as many arguments as possible on a line.</p><p>E.g. with a line width of 11 and using <code>pack</code> instead of <code>stack_or_pack</code> we get the output</p><pre><code class="ml">123456789012345
f
  a b
  (g c d) d</code></pre><p>With a line width of 10 and using <code>pack</code> we get</p><pre><code class="ml">123456789012345
f
  a b
  (g c d)
  d</code></pre><p>because the pretty printer cannot pack <code>(g c d)</code> and <code>d</code> on a single line.</p></header></section><section><header><h3 id="character-stream"><a href="#character-stream" class="anchor"></a>Character Stream</h3><p>The basic type <code>t</code> of the pretty printer is a lazy character stream. I.e. characters are only generated if needed. The pretty printer implements the interface <span class="xref-unresolved" title="unresolved reference to &quot;Module_types.READABLE&quot;"><code>Module_types</code>.READABLE</span> to represent a character stream. You can ask the stream <code>has_more r</code> whether there are more characters in the stream and <code>peek r</code> to get the next character. The instruction <code>advance r</code> returns the stream <code>r</code> advanced by one character position.</p><p>The pretty printer has a function <code>string_of r</code> to return a string representation of the character stream.</p><p>However you very rarely need a string representation of a character stream. All io function in <a href="../Fmlib/index.html"><code>Fmlib</code></a> are able to handle character streams.</p></header></section></section><section><header><h2 id="generate-documents"><a href="#generate-documents" class="anchor"></a>Generate Documents</h2><p>Clearly, it is tedious to write documents by hand. Usually you have some tree like structure and you want to generate a document from the tree structure.</p><p>Let's assume you have a tree structure like</p><pre><code class="ml">type tree =
    { name: string; children: tree list; }

let leaf (name: string): tree =
    {name; children = [] }

let tree (name: string) (children: tree list): tree =
    {name; children}</code></pre><p>Write a function which converts the tree structure to a document.</p><pre><code class="ml">let doc_of_tree (tree: tree): doc =
    let rec doc is_top tree =
        match tree.children with
        | [] -&gt;
            text tree.name
        | _ -&gt;
            let d =
                parent_child
                    &quot; &quot; 2
                    (text tree.name)
                    (children tree.children ())
            in
            if is_top then
                d
            else
                char '(' &lt;+&gt; d &lt;+&gt; char ')'
    and children lst () =
        match lst with
        | [last] -&gt;
            doc false last
        | head :: tail -&gt;
            doc false head &lt;+&gt; space
            &gt;&gt; children tail    (* Lazy concatenation!! *)
        | [] -&gt;
            assert false (* 'lst' is never empty *)
    in
    doc true tree</code></pre><p>Then the simple command</p><pre><code class="ml">tree
    &quot;f&quot;
    [leaf &quot;a&quot;;
     leaf &quot;b&quot;;
     tree &quot;g&quot; [leaf &quot;c&quot;; leaf &quot;d&quot;];
     leaf &quot;e&quot;]
|&gt; layout 10</code></pre><p>generates the character stream</p><pre><code class="ml">123456789012345
f
  a
  b
  (g c d)
  e</code></pre><p>Note the usage of the lazy concatentation operator <code>&gt;&gt;</code> in the recursive part of the function handling the children. This makes sure that even if the tree structure is hugh, the iteration over it is done only on demand. I.e. recursive calls are made only if the corresponding characters are needed when processing the character stream.</p></header></section><section><header><h2 id="api"><a href="#api" class="anchor"></a>API</h2></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>A readable character stream.</p></dd></dl><dl><dt class="spec value" id="val-has_more"><a href="#val-has_more" class="anchor"></a><code><span class="keyword">val</span> has_more : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>has_more r</code> Does the stream <code>r</code> have more characters to read? </p></dd></dl><dl><dt class="spec value" id="val-peek"><a href="#val-peek" class="anchor"></a><code><span class="keyword">val</span> peek : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> char</code></dt><dd><p><code>peek r</code> The next character in the stream <code>r</code>.</p></dd></dl><dl><dt class="spec value" id="val-advance"><a href="#val-advance" class="anchor"></a><code><span class="keyword">val</span> advance : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>advance r</code> The character stream <code>r</code> advance by one position.</p></dd></dl><dl><dt class="spec value" id="val-string_of"><a href="#val-string_of" class="anchor"></a><code><span class="keyword">val</span> string_of : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>string_of r</code> A string representation of the stream <code>r</code>.</p></dd></dl><dl><dt class="spec type" id="type-doc"><a href="#type-doc" class="anchor"></a><code><span class="keyword">type</span> doc</code></dt><dd><p>A document.</p></dd></dl><dl><dt class="spec value" id="val-layout"><a href="#val-layout" class="anchor"></a><code><span class="keyword">val</span> layout : int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>layout width doc</code> Layout the document <code>doc</code> with a the line <code>width</code>.</p></dd></dl><dl><dt class="spec value" id="val-layout_with_ribbon"><a href="#val-layout_with_ribbon" class="anchor"></a><code><span class="keyword">val</span> layout_with_ribbon : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>layout width ribbon doc</code> Layout the document <code>doc</code> with a the line <code>width</code> and the <code>ribbon</code> width. Note: <code>width</code> is the complete line width and <code>ribbon</code> is the line width minus the indentation of the current line.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <a href="index.html#type-doc">doc</a></code></dt><dd><p>An empty document.</p></dd></dl><dl><dt class="spec value" id="val-text"><a href="#val-text" class="anchor"></a><code><span class="keyword">val</span> text : string <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>text str</code> A document with the unbreakable string <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-substring"><a href="#val-substring" class="anchor"></a><code><span class="keyword">val</span> substring : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>substring str start length</code> A document with the unbreakable string <code>str</code> starting at position <code>start</code> and having <code>length</code>.</p></dd></dl><dl><dt class="spec value" id="val-char"><a href="#val-char" class="anchor"></a><code><span class="keyword">val</span> char : char <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>char c</code> A document with the character <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : int <span>&#45;&gt;</span> char <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>fill n c</code> A document with <code>n</code> repetitions of the character <code>c</code>.</p></dd></dl><dl><dt class="spec value" id="val-break"><a href="#val-break" class="anchor"></a><code><span class="keyword">val</span> break : string <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>break str</code> A break hint with the alternative text <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-space"><a href="#val-space" class="anchor"></a><code><span class="keyword">val</span> space : <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>space</code> A break hint with a blank as alternative text.</p></dd></dl><dl><dt class="spec value" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span class="keyword">val</span> cut : <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>cut</code> A break hint with an empty alternative text.</p></dd></dl><dl><dt class="spec value" id="val-group"><a href="#val-group" class="anchor"></a><code><span class="keyword">val</span> group : <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>group doc</code></p><p>Treat all break hints belonging directly to <code>doc</code> consistently. Either print all as newlines or print all with their alternative text.</p><p>This is the basic operation to decide break hints.</p><p>If the whole group and all text which follows until the next break hint after the group fits on a line, then all break hints (directly or indirectly) in the group are flattened i.e. printed with their alternative texts.</p><p>If the whole group does not fit, then all break hints belonging directly to the group are printed as effective newlines. The break hints of inner groups are considered separately.</p></dd></dl><dl><dt class="spec value" id="val-nest"><a href="#val-nest" class="anchor"></a><code><span class="keyword">val</span> nest : int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>nest n doc</code></p><p>The document <code>doc</code> indented by <code>n</code> blanks.</p><p>This is the basic function to indicate a substructure to the pretty printer. The substructure is indented with respect to the parent document.</p><p>The indentation is valid after each effective line break. It is usually convenient to group the whole substructure and put a break hint before the group and group the parent structure and the substructure. This makes sure that either the parent and the child fit on a line or the child begins on a newline and is indented. See the function <code>parent_child</code> below which does exactly that.</p></dd></dl><dl><dt class="spec value" id="val-parent_child"><a href="#val-parent_child" class="anchor"></a><code><span class="keyword">val</span> parent_child : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>parent_child hint indent parent child</code></p><p>Put the parent and the child in a group and separate them by a break hint with the alternative text <code>hint</code>. Furthermore put the child in a separate group.</p><p>Equivalent to</p><pre><code class="ml">parent
&lt;+&gt; break hint
&lt;+&gt; nest indent (group child)
|&gt; group</code></pre></dd></dl><dl><dt class="spec value" id="val-with_width"><a href="#val-with_width" class="anchor"></a><code><span class="keyword">val</span> with_width : int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>with_width n doc</code> Format the document <code>doc</code> with line <code>width</code>.</p></dd></dl><dl><dt class="spec value" id="val-with_ribbon"><a href="#val-with_ribbon" class="anchor"></a><code><span class="keyword">val</span> with_ribbon : int <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>with_ribbon n doc</code> Format the document <code>doc</code> with <code>ribbon</code> width.</p></dd></dl><dl><dt class="spec value" id="val-(&lt;+&gt;)"><a href="#val-(&lt;+&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&lt;+&gt;) : <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>doc1 &lt;+&gt; doc2</code> Concatentate the documents <code>doc1</code> and <code>doc2</code>.</p></dd></dl><dl><dt class="spec value" id="val-(&gt;&gt;)"><a href="#val-(&gt;&gt;)" class="anchor"></a><code><span class="keyword">val</span> (&gt;&gt;) : <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a>)</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>doc &gt;&gt; lazy_doc</code> Concatenate the document <code>doc</code> with the lazy document <code>lazy_doc</code>.</p></dd></dl><dl><dt class="spec value" id="val-cat"><a href="#val-cat" class="anchor"></a><code><span class="keyword">val</span> cat : <span><a href="index.html#type-doc">doc</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>cat list</code> Concatenate all documents in the <code>list</code> of documents.</p></dd></dl><dl><dt class="spec value" id="val-separated_by"><a href="#val-separated_by" class="anchor"></a><code><span class="keyword">val</span> separated_by : <a href="index.html#type-doc">doc</a> <span>&#45;&gt;</span> <span><a href="index.html#type-doc">doc</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>separated_by sep list</code> Concatenate all documents in the <code>list</code> of documents separated by <code>sep</code>.</p></dd></dl><dl><dt class="spec value" id="val-pack"><a href="#val-pack" class="anchor"></a><code><span class="keyword">val</span> pack : string <span>&#45;&gt;</span> <span><a href="index.html#type-doc">doc</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>pack str list</code> Pack as much documents of the <code>list</code> of documents as possible into a line. I.e. separate all documents by a break hint with <code>str</code> as an alternative text.</p></dd></dl><dl><dt class="spec value" id="val-stack"><a href="#val-stack" class="anchor"></a><code><span class="keyword">val</span> stack : string <span>&#45;&gt;</span> <span><a href="index.html#type-doc">doc</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>stack str list</code> The same as <code>separated_by (break str) list</code>.</p></dd></dl><dl><dt class="spec value" id="val-stack_or_pack"><a href="#val-stack_or_pack" class="anchor"></a><code><span class="keyword">val</span> stack_or_pack : string <span>&#45;&gt;</span> <span><a href="index.html#type-doc">doc</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>stack_or_pack str list</code> Separate all documents of the <code>list</code> by a break hint with alternative text <code>str</code> and either print all break hints as newlines of with the alternative text <code>str</code>.</p></dd></dl><dl><dt class="spec value" id="val-wrap_words"><a href="#val-wrap_words" class="anchor"></a><code><span class="keyword">val</span> wrap_words : string <span>&#45;&gt;</span> <a href="index.html#type-doc">doc</a></code></dt><dd><p><code>wrap_words str</code> Split the string <code>str</code> into words (words are substrings of <code>str</code> not containing blanks) and pack as many of them onto a line.</p></dd></dl></section></div></body></html>